
import JackTokenizer

class CompilationEngine():
    """
    The compilation engine gets its input from a JackTokenizer, 
    and emits its output to an output file.
    The output is generated by a series of compilexxx routines, 
    each designed to handle the compilation of a specific Jack language construct xxx.
    The contract between these rountines is that each compilexxx routine should get from the input,
    and handle, all the tokens that make up xxx, advance the tokenizer exactly beyond these tokens,
    and output the parsing of xxx.
    As a rule, each compilexxx routine is called only if the current token is xxx.
    """
    def __init__(self, inputfile, outputfile):
        """
        Creates a new compilation engine with the given input and output.
        The next routine called (by the JackAnalyzer module) must be compileClass.
        """
        self.input = JackTokenizer.JackTokenizer(inputfile)
        self.f = open(outputfile, "w") 
        self.op = ['+','-','*','/','&amp;','|','&lt;','&gt;','=']
        self.indent = 0
        self.input.advance()
            
    def compileClass(self):
        """
        Compiles a complete class.
        """
        self.f.write('{}<class>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # class
        self.process() # className
        self.process() # {
        while (self.input.keyWord() == 'static') or (self.input.keyWord() == 'field'):
            self.compileClassVarDec() # classVarDec
        while (self.input.keyWord() == 'constructor') or (self.input.keyWord() == 'function') \
        or (self.input.keyWord() == 'method'):
            self.compileSubroutine() # subroutineDec
        self.process() # }
        self.indent -= 2
        self.f.write('{}</class>\n'.format(' '*self.indent))
        
    def compileClassVarDec(self):
        """
        Compiles a static variable declaration, or a field declaration.
        """
        self.f.write('{}<classVarDec>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # static|field
        self.process() # type
        self.process() # varName
        while (self.input.symbol() == ','):
            self.process() # ,
            self.process() # varName
        self.process() # ;
        self.indent -= 2
        self.f.write('{}</classVarDec>\n'.format(' '*self.indent))
        
    def compileSubroutine(self):
        """
        Compiles a complete method, function, or constructor.
        """
        self.f.write('{}<subroutineDec>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # constructor|function|method
        self.process() # void|type
        self.process() # subroutineName
        self.process() # (
        self.compileParameterList() # parameterList
        self.process() # )
        self.compileSubroutineBody() # subroutineBody
        self.indent -= 2
        self.f.write('{}</subroutineDec>\n'.format(' '*self.indent))
        
    def compileParameterList(self):
        """
        Compiles a (possibly empty) parameter list.
        Does not handle the enclosing parentheses tokens '(' and ')'.
        """
        self.f.write('{}<parameterList>\n'.format(' '*self.indent))
        self.indent += 2
        if self.input.symbol() != ')':
            self.process() # type
            self.process() # varName
            while self.input.symbol() == ',':
                self.process() # ,
                self.process() # type
                self.process() # varName
        self.indent -= 2
        self.f.write('{}</parameterList>\n'.format(' '*self.indent))
        
    def compileSubroutineBody(self):
        """
        Compiles a subroutine's body.
        """
        self.f.write('{}<subroutineBody>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # {
        while self.input.keyWord() == 'var':
            self.compileVarDec() # varDec
        self.compileStatements() # statements
        self.process() # }
        self.indent -= 2
        self.f.write('{}</subroutineBody>\n'.format(' '*self.indent))
        
    def compileVarDec(self):
        """
        Compiles a var declaration.
        """
        self.f.write('{}<varDec>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # var
        self.process() # type
        self.process() # varName
        while self.input.symbol() == ',':
            self.process() # ,
            self.process() # varName
        self.process() # ;
        self.indent -= 2
        self.f.write('{}</varDec>\n'.format(' '*self.indent))
        
    def compileStatements(self):
        """
        Compiles a sequence of statements.
        Does not handle the enclosing curly bracket tokens '{' and '}'.
        """
        self.f.write('{}<statements>\n'.format(' '*self.indent))
        self.indent += 2
        while self.input.keyWord() in ['let', 'if', 'while', 'do', 'return']:
            if self.input.keyWord() == 'let':
                self.compileLet()
            elif self.input.keyWord() == 'if':
                self.compileIf()
            elif self.input.keyWord() == 'while':
                self.compileWhile()
            elif self.input.keyWord() == 'do':
                self.compileDo()
            elif self.input.keyWord() == 'return':
                self.compileReturn()
        self.indent -= 2
        self.f.write('{}</statements>\n'.format(' '*self.indent))
        
    def compileLet(self):
        """
        Compiles a let statement.
        """
        self.f.write('{}<letStatement>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # let
        self.process() # varName
        if self.input.symbol() == '[':
            self.process() # [
            self.compileExpression() # expression
            self.process() # ]
        self.process() # =
        self.compileExpression() # expression
        self.process() # ;
        self.indent -= 2
        self.f.write('{}</letStatement>\n'.format(' '*self.indent))
        
    def compileIf(self):
        """
        Compiles an if statement, possibly with a trailing else clause.
        """
        self.f.write('{}<ifStatement>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # if
        self.process() # (
        self.compileExpression() # expression
        self.process() # )
        self.process() # {
        self.compileStatements() # statements
        self.process() # }
        if self.input.keyWord() == 'else':
            self.process() # else
            self.process() # {
            self.compileStatements() # statements
            self.process() # }
        self.indent -= 2
        self.f.write('{}</ifStatement>\n'.format(' '*self.indent))
    
    def compileWhile(self):
        """
        Compiles a while statement.
        """
        self.f.write('{}<whileStatement>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # while
        self.process() # (
        self.compileExpression() # expression
        self.process() # )
        self.process() # {
        self.compileStatements() # statements
        self.process() # }
        self.indent -= 2
        self.f.write('{}</whileStatement>\n'.format(' '*self.indent))
        
    def compileDo(self):
        """
        Compiles a do statement.
        """
        self.f.write('{}<doStatement>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # do
        self.process() # subroutineName|className|varName
        # subroutineCall
        if self.input.symbol() == '(': # subroutineName(expressionList)
            self.process() # (
            self.compileExpressionList() # expressionList
            self.process() # )
        elif self.input.symbol() == '.': # (className|varName).subroutineName(expressionList)
            self.process() # .
            self.process() # subroutineName
            self.process() # (
            self.compileExpressionList()
            self.process() # )
        self.process() # ;
        self.indent -= 2
        self.f.write('{}</doStatement>\n'.format(' '*self.indent))
        
    def compileReturn(self):
        """
        Compiles a return statement.
        """
        self.f.write('{}<returnStatement>\n'.format(' '*self.indent))
        self.indent += 2
        self.process() # return
        if self.input.symbol() != ';':
            self.compileExpression() # expression
        self.process() # ;
        self.indent -= 2
        self.f.write('{}</returnStatement>\n'.format(' '*self.indent))
        
    def compileExpression(self):
        """
        Compiles an expression.
        """
        self.f.write('{}<expression>\n'.format(' '*self.indent))
        self.indent += 2
        self.compileTerm() # term
        while self.input.symbol() in self.op:
            self.process() # op
            self.compileTerm() # term
        self.indent -= 2
        self.f.write('{}</expression>\n'.format(' '*self.indent))
        
    def compileTerm(self):
        """
        Compiles a term.
        If the current token is an identifier, the routine must resolve it into:
        a variable, an array element, or a subroutine call.
        A single lookahead token, which may be '[', '(', or '.', 
        suffices to distinguish between the possibilities.
        Any other token is not part of this term and should not be advanced over.
        """
        self.f.write('{}<term>\n'.format(' '*self.indent))
        self.indent += 2
        if self.input.tokenType() == 'integerConstant':
            self.process() # integerConstant
        elif self.input.tokenType() == 'stringConstant':
            self.process() # stringConstant
        elif self.input.tokenType() == 'keyword':
            self.process() # keywordConstant
        elif self.input.symbol() == '(': # (expression))
            self.process() # (
            self.compileExpression() # expression
            self.process() # )
        elif (self.input.symbol() == '-') or (self.input.symbol() == '~'): # unaryOp term
            self.process() # unaryOp
            self.compileTerm() # term
        else: # varName or varName[expression] or subroutineCall
            self.process() # varName|subroutineName|className|varName
            if self.input.symbol() == '[': # varName[expression]
                self.process() # [
                self.compileExpression() # expression
                self.process() # ]
            elif self.input.symbol() == '(': # subroutineName(expressionList)
                self.process() # (
                self.compileExpressionList() # expressionList
                self.process() # )
            elif self.input.symbol() == '.': # (className|varName).subroutineName(expressionList)
                self.process() # .
                self.process() # subroutineName
                self.process() # (
                self.compileExpressionList()
                self.process() # )
        self.indent -= 2
        self.f.write('{}</term>\n'.format(' '*self.indent))
        
    def compileExpressionList(self):
        """
        Compiles a (possibly empty) comma-sparated list of expressions.
        Returns the number of expressions in the list.
        Returns: int
        """
        self.f.write('{}<expressionList>\n'.format(' '*self.indent))
        self.indent += 2
        if self.input.symbol() != ')':
                self.compileExpression() # expression
                while self.input.symbol() == ',':
                    self.process() # ,
                    self.compileExpression() # expression
        self.indent -= 2
        self.f.write('{}</expressionList>\n'.format(' '*self.indent))

    def close(self):
        """
        Closes the output file.
        """
        self.f.close()
        
    def process(self):
        """
        A helper function that handles the current token, and advances to get the next token.
        """
        if self.input.tokenType() == 'keyword':
            self.f.write('{}<keyword> {} </keyword>\n'.format(' '*self.indent, self.input.keyWord()))
        elif self.input.tokenType() == 'symbol':
            self.f.write('{}<symbol> {} </symbol>\n'.format(' '*self.indent, self.input.symbol()))
        elif self.input.tokenType() == 'identifier':
            self.f.write('{}<identifier> {} </identifier>\n'.format(' '*self.indent, self.input.identifier()))
        elif self.input.tokenType() == 'integerConstant':
            self.f.write('{}<integerConstant> {} </integerConstant>\n'.format(' '*self.indent, self.input.intVal()))
        elif self.input.tokenType() == 'stringConstant':
            self.f.write('{}<stringConstant> {} </stringConstant>\n'.format(' '*self.indent, self.input.stringVal()))
        self.input.advance()
        
